* Svelte 5 komande
- primarni izvor je [svelte.dev/tutorial](https://svelte.dev/tutorial/svelte/default-values) za novu Svelte3 sintaksu i SvelteKit

** Rune
*** $state()
  - koristi se kada god se želi varijabla dinamičkim mijenjati unutar komponente
#+begin_src web
      <script>
      let varijabla = $state(["nekakva vrijednost"])
      </script>
      <p>{varijabla}</p>
#+end_src
*** $derived()
  - koristi se za dinamične varijable čija vrijednost ovisi o vrijednostima drugih $state varijabli
    #+begin_src web
       <script>
       let broj = $state(2)
       let duplo = $derived(broj * 2)
       </script>

      <button onclick={()=>broj++}>+</button>
      <p>Broj je {broj}, a dvostruko je {duplo}.</p>
#+end_src
*** $state.snapshot() i $inspect()[.with()]
  - su rune za kontrolu vrijednosti varijabli tijekom rada aplikacije koje ispisuju u konzoli kada god dođe do promjene vrijednosti ~$state~ varijable
    #+begin_src web
      <script>
      let varijabla = $state(42)
      // conslole.log($state.snapshot(varijabla))
      $inspect(varijabla)
      </script>
#+end_src
*** $effect(()=>{})
  - je runa za postavljanja vlastitih reaktivnih efekata (odnosno, ponovnog vrćenja ~$effect~ bloka čim se neka $state varijabla korištena unutar njega promijeni)
    - preporuka je što manje koristiti ~$effect~ runu
    #+begin_src web
      <script>
	      let elapsed = $state(0);
	      let interval = $state(1000);
	      $effect(()=>{
		      const tempo = setInterval(()=>elapsed++, interval)
		      return ()=>clearInterval(tempo)
	      })
      </script>
      <button onclick={() => interval /= 2}>speed up</button>
      <button onclick={() => interval *= 2}>slow down</button>
      <p>elapsed: {elapsed}</p>
#+end_src
*** $props()
  - je runa koja služi za dohvaćanje vrijednosti proslijeđenih iz roditeljskog elementa, a proslijeđivati se mogu bilokakvi objekti, od primitivnih vrijednosti do funkcija koje zarobljavaju (*capture*) vari
    #+begin_src web
      <!-- u Parent.svelte -->
      <script>
      import Child from ./Child.svelte
      let age = $state(0)
      </script>
      <p>Dijete je staro {age} godina.</p>
      <Child ime="Borislav" growup={()=>{age++}}/>
#+end_src

    #+begin_src web
      <!-- u Child.svelte -->
      <script>
      export let { ime = "tvorničko ime", growup } = $props()
      </script> 
      <p>Dijete se zove { ime }</p>
      <button onclick={growup}></button>
#+end_src

** Blokovi
*** {#if:else/if}
  - su blokovi za uvjetno ubacivanje koda kada je neki proizvoljni kriterij zadovoljen
    #+begin_src web
      <script>
      let count = $state(0)
      </script>
      <button onclick={()=>count++}>+</button>

      {#if count > 10}
      <p>{count} &gt; 10</p>
      {:else if count < 5}
      <p>{count} &lt; 5</p>
      {:else}
      <p>5 &le; {count} &le; 10</p>
      {/if}
#+end_src
*** {#each/each}
  - su blokovi za izbjegavanje repetitivnog koda
    #+begin_src web
      <ol>
      {#each ['prvo', 'drugo', treće'] as stavka, i (stavka)}
      <li>ovo je {i}. stavka ({stavka})</li>
      {/each}
      </ol>
#+end_src
*** {#await:then:catch/await}
  - blokovi za nošenje sa asinhronim dohvaćanjem podataka (omogućuju čekanje da se /Promise/ ispuni i onda preiscrtavanja novog sadržaja)
    #+begin_src web
      <script>
      import { getPromise } from './utils.js'
      let promise = $state( getPromise() )
      </script>
      {#await promise
      <p>...downloading...</p>
      {:then paket}
      <p>Ovo je pristiglo {paket}</p>
      {:catch error}
      <p style="color: red">Grješka je u {error.message}!</p>
      {/await}
#+end_src
** DOM & events
*** onclick
  - ima već gore dovoljno primjera. Običan onclick eventListener.
*** onpointermove
#+begin_src web
  <script>
  let m = $state({x:0,y:0})
  function onpointermove(event) {
      m.x = event.clientX
      m.y = event.clientY
  }
  </script>
  <p>Miš se sada nalazi na koordinatama {Math.round(m.x)} × {Math.round(m.y)}.</p>
#+end_src
*** (.)*capture
- je dodatak na naziv eventa ako se želi uhvatiti događaj za vrijeme /capture/ faze, mjesto defaultne /bubble/ faze.
** Vezanje (/binding/)
- /tijek podataka/ se u Svelte-u provodi uglavnom provodi odozgo-nadole (roditelji proslijeđuju vrijednosti (/props/) komponentama, komponente proslijeđuju podatke svojim elementima). Tome uskaće u pomoć ~bind:~ prefiks atributima elemenata, tako da roditelji mogu odmah znati čim se djeci promijeni vrijednost bilo kojeg atributa, a ta veza može biti uspostavljena između svih elemenata nekog roditelja.
*** bind:value
  #+begin_src web
    <script>
    let value = $state(5)
    </script>
    <p>Trenutna vrijednost je <strong>{vrijednost}</strong>.</p>
    <input bind:value type="number" /> <!-- mogu napisati samo bind:value, a ne bind:value={value} zato što je istoimena varijabla upotrijebljena za čuvanje vrijednosti -->
    <input bind:value type="range" min=0 max=10 />
#+end_src
*** bind:group
- se koristi kod vezanja vrijednosti višestukih inputa (npr. sa /radio/ i /checkbox/ inputima).
  #+begin_src web
    <script>let vrijednost = $state</script>
    <input type="radio" name="vrijednost" value=1 bind:group={vrijednost}>
    <input type="radio" name="vrijednost" value=2 bind:group={vrijednost}>
    <input type="radio" name="vrijednost" value=3 bind:group={vrijednost}>
    <p>Odabrana vrijednost je {vrijednost}.</p>
#+end_src
*** bind:this
- je poseban binding koji omogućuje Svelte-u da dinamički pohrani referencu na neki element čim se ovaj učita
 #+begin_src web
   <script>
   let h1 = $state()
   $effect(()=>{
     h1.textContent = "Novi naslov"
   })
   </script>
   <h1 bind:this={h1}>Naslov</h1>
 #+end_src
** Stilovi i klase
*** class
- navodno uobičajen atribut za selektiranje preko CSS-a (?), pa onda Svelte nudi neke prečce za baratanje sa vrijednostima tog atributa
 #+begin_src web
   <!-- kod kondicionalnog zadavanja klasa -->
   <div class="veliki {plavi ? 'plavi' : ''}" />
   <!-- je isto kao i -->
   <div class={[ 'veliki', {plavi} ]} />
  #+end_src
*** style:
- ~style:~ direktiva je za unošenje vrijednosti za =style= atribut, ali na jednostavniji i čitkiji način, doduše dosta repetitatitetititiotitutivniji. Mogu se zadavati vrijednosti bilo kojeg CSS svojstva i/ili (re)definirati CSS varijable
  #+begin_src web
    <div
      style:transform="rotateZ(20)" 
      style:font-family="cursive" 
      style:--text-size="14px"  
    ></div>
#+end_src
- a još jednostavniji način definiranja CSS varijabli je njihovo proslijeđivanje pomalo kao atributa/prop-a (samo što se ne treba posebno učitavati u startu). To se temelji na Svelteovom dodavanju nekakvog novog /roditelj>svelte-css-wrapper>dijete/ elementa, pa treba biti oprezan pri oblikovanju selektora jer je narušen neposredan odnos /roditelj>dijete/.
  #+begin_src web
    <!-- u roditelju -->
    <script>
    import Semafor from "./Semafor.svelte"
    </script>
    <Semafor --background="red" />
    <Semafor --background="yellow" />
    <Semafor --background="green" />
#+end_src

  #+begin_src web
    <!-- u djetetu -->
    <div></div>

    <style>
      div {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background-color: var(--background, #333);
    }
    </style>
#+end_src

** Akcije
- Svelte akcije prate životni-ciklus elementa. Korisne su kod rada sa vanjskim resursima i knjižnicama, /lazy loading/-a, iskakanja /tooltip/-a i dodavanja vlastitih /EventHandler/-a.
